{
    "description":  "Schema for the Qpid Dispatch Router management model. See qdrouter.json.readme.txt.",

    "prefix": "org.apache.qpid.dispatch",

    "entityTypes": {

        "entity": {
            "description": "Base entity type for all entities.",
            "attributes": {
                "name": {
                    "type": "string",
                    "unique": true,
                    "description": "Unique name optionally assigned by user. Can be changed.",
                    "create": true
                },
                "identity": {
                    "type": "string",
                    "unique": true,
                    "description": "Unique identity generated by the system. Will not change."
                },
                "type": {
                    "type": "string",
                    "required": true,
                    "description": "Management entity type.",
                    "create": true
                }
            },

            "operationDefs": {
                "CREATE": {
                    "description": "Create a new entity.",
                    "request": {
                        "properties": {
                            "name": {
                                "description": "Name of new entity. Optional, defaults to identity.",
                                "type": "string"
                            },
                            "type": {
                                "description": "Type of new entity.",
                                "type": "string",
                                "required": true
                            }
                        },
                        "body": {
                            "description": "Attributes for the new entity. Can include name and/or type.",
                            "type": "map",
                            "required": true
                        }
                    },
                    "response": {
                        "body": {
                            "description": "Attributes of the entity",
                            "type": "map"
                        }
                    }
                },
                "READ": {
                    "description": "Read attributes of a single entity",
                    "request": {
                        "properties": {
                            "name": {
                                "description": "Name of desired entity. Must supply name or identity.",
                                "type": "string"
                            },
                            "identity": {
                                "description": "Identity of desired entity. Must supply name or identity.",
                                "type": "string"

                            },
                            "type": {
                                "description": "Type of desired entity.",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "Attributes of the entity",
                            "type": "map"
                        }
                    }
                },
                "UPDATE": {
                    "description": "Update attributes of an entity",
                    "request": {
                        "properties": {
                            "name": {
                                "description": "Name of desired entity. Must supply name or identity.",
                                "type": "string"
                            },
                            "identity": {
                                "description": "Identity of desired entity. Must supply name or identity.",
                                "type": "string"
                            },
                            "type": {
                                "description": "Type of desired entity.",
                                "type": "string"
                            }
                        },
                        "body": {
                            "description": "Attributes to update for the entity. Can include name or identity.",
                            "type": "map"
                        }
                    },
                    "response": {
                        "body": {
                            "description": "Updated attributes of the entity",
                            "type": "map"
                        }
                    }
                },
                "DELETE": {
                    "description": "Delete an entity",
                    "request": {
                        "properties": {
                            "name": {
                                "description": "Name of desired entity. Must supply name or identity.",
                                "type": "string"

                            },
                            "identity": {
                                "description": "Identity of desired entity. Must supply name or identity.",
                                "type": "string"
                            },
                            "type": {
                                "description": "Type of desired entity.",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },

        "org.amqp.management": {
            "description": "The standard AMQP management node interface.",
            "fullName": true,
            "extends": "operationalEntity",
            "operations": ["QUERY", "GET-TYPES", "GET-ANNOTATIONS", "GET-OPERATIONS", "GET-ATTRIBUTES", "GET-MGMT-NODES"],
            "operationDefs": {
                "QUERY": {
                    "description": "Query for attribute values of multiple entities.",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "entityType": {
                                "description": "If set, restrict query results to entities that extend (directly or indirectly) this type",
                                "type": "string"
                            },
                            "offset": {
                                "description": "If set, specifies the number of the first element of the result set to be returned.",
                                "type": "integer",
                                "default": 0
                            },
                            "count": {
                                "description": "If set, specifies the number of entries from the result set to return. If not set return all from `offset`",
                                "type": "integer"
                            }
                        },
                        "body": {
                            "description": "A map containing the key `attributeNames` with value a list of (string) attribute names to return. If the list or the map is empty or the body is missing all attributes are returned.",
                            "type": "map"
                        }
                    },
                    "response": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "count": {
                                "description": "Number of results returned",
                                "type": "integer"
                            }
                        },
                        "body": {
                            "description": "A map with two entries. `attributeNames` is a list of the attribute names returned. `results` is a list of lists each containing the attribute values for a single entity in the same order as the names in the `attributeNames` entry. If an attribute name is not applicable for an entity then the corresponding value is `null`",
                            "type": "map"
                        }
                    }
                },
                "GET-TYPES": {
                    "description": "Get the set of entity types and their inheritance relationships",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "entityType": {
                                "description": "If set, restrict query results to entities that extend (directly or indirectly) this type",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A map where each key is an entity type name (string) and the corresponding value is the list of the entity types (strings) that it extends.",
                            "type": "map"
                        }
                    }
                },
                "GET-OPERATIONS": {
                    "description": "Get the set of entity types and the operations they support",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "entityType": {
                                "description": "If set, restrict query results to entities that extend (directly or indirectly) this type",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A map where each key is an entity type name (string) and the corresponding value is the list of operation names (strings) that it supports.",
                            "type": "map"
                        }
                    }
                },
                "GET-ANNOTATIONS": {
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "entityType": {
                                "description": "If set, restrict query results to entities that extend (directly or indirectly) this type",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A map where each key is an entity type name (string) and the corresponding value is the list of annotations (strings) that it  implements.",
                            "type": "map"
                        }
                    }
                },
                "GET-ATTRIBUTES": {
                    "description": "Get the set of entity types",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "entityType": {
                                "description": "If set, restrict query results to entities that extend (directly or indirectly) this type",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A map where each key is an entity type name (string) and the corresponding value is a list (of strings) of attributes on that entity type.",
                            "type": "map"
                        }
                    }
                },
                "GET-MGMT-NODES": {
                    "description": "Get the addresses of all management nodes known to this router",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A list of addresses (strings) of management nodes known to this management node.",
                            "type": "list"
                        }
                    }
                }
            }
        },

        "management": {
            "description": "Qpid dispatch router extensions to the standard org.amqp.management interface.",
            "extends": "org.amqp.management",
            "singleton": true,
            "operations": ["GET-SCHEMA", "GET-JSON-SCHEMA", "GET-LOG", "PROFILE"],
            "operationDefs": {
                "GET-SCHEMA": {
                    "description": "Get the qdrouterd schema for this router in AMQP map format",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "The qdrouter schema as a map.",
                            "type": "map"
                        }
                    }
                },
                "GET-SCHEMA-JSON": {
                    "description": "Get the qdrouterd schema for this router in JSON format",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "indent": {
                                "description": "Number of spaces to indent the formatted result. If not specified, the result is in minimal format, no unnecessary spaces or newlines.",
                                "type": "integer"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "The qdrouter schema as a JSON string.",
                            "type": "string"
                        }
                    }
                },
                "GET-LOG": {
                    "description": "Get recent log entries from the router.",
                    "request": {
                        "properties": {
                            "identity": {
                                "description": "Set to the value `self`",
                                "type": "string"
                            },
                            "limit": {
                                "description": "Maximum number of log entries to get.",
                                "type": "integer"
                            }
                        }
                    },
                    "response": {
                        "body": {
                            "description": "A list of log entries where each entry is a list of: module name(string), level name(string), message text(string), file name(string or None), line number(integer or None) , timestamp(integer)",
                            "type": "string"
                        }
                    }
                }
            }
        },

        "configurationEntity": {
            "description": "Base type for entities containing configuration information.",
            "extends": "entity",
            "attributes": {},
            "operations": ["READ"]
        },

        "operationalEntity": {
            "description": "Base type for entities containing current operational information.",
            "extends": "entity",
            "operations": ["READ"],
            "attributes": {}
        },

        "router": {
            "description":"Tracks peer routers and computes routes to destinations. This entity is mandatory. The router will not start without this entity.",
            "extends": "configurationEntity",
            "singleton": true,
            "attributes": {
                "id": {
                    "description":"Router's unique identity. The router will fail to start without id.",
                    "type": "string",
                    "required": false,
                    "create": true
                },
                "mode": {
                    "type": [
                        "standalone",
                        "interior",
                        "edge"
                    ],
                    "default": "standalone",
                    "description": "In standalone mode, the router operates as a single component.  It does not participate in the routing protocol and therefore will not cooperate with other routers. In interior mode, the router operates in cooperation with other interior routers in an interconnected network.  In edge mode, the router can make an uplink to an interior router and join a network without causing that network to recompute paths.",
                    "create": true
                },
                "area": {
                    "type": "string",
                    "description": "Unused placeholder.",
                    "default": 0
                },
                "version": {
                    "type": "string",
                    "description": "Software Version"
                },
                "hostName": {
                    "type": "string",
                    "description": "hostName of machine on which router is running"
                },
                "helloIntervalSeconds": {
                    "type": "integer",
                    "default": 1,
                    "description": "Interval in seconds between HELLO messages sent to neighbor routers.",
                    "deprecationName": "helloInterval",
                    "create": true
                },
                "helloMaxAgeSeconds": {
                    "type": "integer",
                    "default": 3,
                    "description": "Time in seconds after which a neighbor is declared lost if no HELLO is received.",
                    "deprecationName": "helloMaxAge",
                    "create": true
                },
                "raIntervalSeconds": {
                    "type": "integer",
                    "default": 30,
                    "description": "Interval in seconds between Router-Advertisements sent to all routers in a stable network.",
                    "deprecationName": "raInterval",
                    "create": true
                },
                "raIntervalFluxSeconds": {
                    "type": "integer",
                    "default": 4,
                    "description": "Interval in seconds between Router-Advertisements sent to all routers during topology fluctuations.",
                    "deprecationName": "raIntervalFlux",
                    "create": true
                },
                "remoteLsMaxAgeSeconds": {
                    "type": "integer",
                    "default": 60,
                    "description": "Time in seconds after which link state is declared stale if no RA is received.",
                    "deprecationName": "remoteLsMaxAge",
                    "create": true
                },
                "workerThreads": {
                    "type": "integer",
                    "default": 4,
                    "description": "The number of threads that will be created to process message traffic and other application work (timers, non-amqp file descriptors, etc.) .",
                    "create": true
                },
                "debugDumpFile": {
                    "type": "path",
                    "description": "The absolute path to the location for the debug dump file. The router writes debug-level information to this file if the logger is not available.",
                    "deprecationName": "debugDump",
                    "create": true
                },
                "saslConfigDir": {
                    "type": "path",
                    "description": "Absolute path to the SASL configuration file.",
                    "deprecationName": "saslConfigPath",
                    "required": false,
                    "create": true
                },
                "saslConfigName": {
                    "type": "string",
                    "description": "Name of the SASL configuration.  This string + '.conf' is the name of the configuration file.",
                    "default": "qdrouterd",
                    "required": false,
                    "create": true
                },
                "allowResumableLinkRoute": {
                    "type": "boolean",
                    "description": "Whether links can be routed where timeout is non-zero or expiry-policy is not link-detach",
                    "create": true,
                    "required": false,
                    "default": true
                },                
                "allowUnsettledMulticast": {
                    "type": "boolean",
                    "description": "(DEPRECATED) If true, allow senders to send unsettled deliveries to multicast addresses.  These deliveries shall be settled by the ingress router.  If false, unsettled deliveries to multicast addresses shall be rejected.",
                    "create": true,
                    "required": false,
                    "default": false
                },
                "defaultDistribution": {
                    "type": ["multicast", "closest", "balanced", "unavailable"],
                    "description": "Default forwarding treatment for any address without a specified treatment. multicast - one copy of each message delivered to all subscribers; closest - messages delivered to only the closest subscriber; balanced - messages delivered to one subscriber with load balanced across subscribers; unavailable - this address is unavailable, link attaches to an address of unavilable distribution will be rejected.",
                    "create": true,
                    "required": false,
                    "default": "balanced"
                },
	            "addrCount": {
	                "type": "integer",
	                "description":"Number of addresses known to the router.",
	                "graph": true
	            },
	            "linkCount": {
	                "type": "integer",
	                "description":"Number of links attached to the router node.",
	                "graph": true
	            },
	            "nodeCount": {
	                "type": "integer",
	                "description":"Number of known peer router nodes.",
	                "graph": true
	            },
	            "linkRouteCount": {
	                "type": "integer",
	                "description":"Number of link routes attached to the router node.",
	                "graph": true
	            },
	            "autoLinkCount": {
	                "type": "integer",
	                "description":"Number of auto links attached to the router node.",
	                "graph": true
	            },
	            "connectionCount": {
	                "type": "integer",
	                "description":"Number of open connections to the router node.",
	                "graph": true
	            },
                "presettledDeliveries": {
                    "type": "integer",
                    "description":"Number of presettled deliveries handled by the router.",
                    "graph": true
                },
                "droppedPresettledDeliveries": {
                    "type": "integer",
                    "description":"Number of presettled deliveries that were dropped by the router.",
                    "graph": true
                },
                "acceptedDeliveries": {
                    "type": "integer",
                    "description":"Number of deliveries whose delivery state was set to ACCEPTED by the router. These deliveries were successfully processed by the router.",
                    "graph": true
                },
                "rejectedDeliveries": {
                    "type": "integer",
                    "description":"Number of deliveries whose delivery state was set to REJECTED by the router. These deliveries were Invalid and unprocessable.",
                    "graph": true
                },
                "releasedDeliveries": {
                    "type": "integer",
                    "description":"Number of deliveries whose delivery state was set to RELEASED by the router. These deliveries was not (and will not be) processed",
                    "graph": true
                },
                "modifiedDeliveries": {
                    "type": "integer",
                    "description":"Number of deliveries whose delivery state was set to MODIFIED by the router. These deliveries were modified but not processed.",
                    "graph": true
                },
                "deliveriesIngress": {
                    "type": "integer",
                    "description":"Number of deliveries that were sent to it by a sender that is directly attached to the router.",
                    "graph": true
                },
                "deliveriesEgress": {
                    "type": "integer",
                    "description":"Number of deliveries that were sent by the router to a receiver that is directly attached to the router.",
                    "graph": true
                },
                "deliveriesTransit": {
                    "type": "integer",
                    "description":"Number of deliveries that were sent to another router in the network.",
                    "graph": true
                },                
                "deliveriesIngressRouteContainer": {
                    "type": "integer",
                    "description":"Number of deliveries that were received from router container connections.",
                    "graph": true
                },                
                "deliveriesEgressRouteContainer": {
                    "type": "integer",
                    "description":"Number of deliveries that were sent to route container connections.",
                    "graph": true
                }                
            }
        },       
        "sslProfile": {
            "description":"Attributes for setting TLS/SSL configuration for connections.",
            "referential": true,
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "ciphers": {
                    "type": "string",
                    "description": "Specifies the enabled ciphers so the SSL Ciphers can be hardened. In other words, use this field to disable weak ciphers. The ciphers are specified in the format understood by the OpenSSL library. For example, ciphers can be set to ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; -- The full list of allowed ciphers can be viewed using the openssl ciphers command",
                    "create": true
                },      
                "protocols": {
                    "type": "string",
                    "description": "The TLS protocols that this sslProfile can use. You can specify a list of one or more of TLSv1, TLSv1.1, or TLSv1.2. To specify multiple protocols, separate the protocols with a space. For example, to permit the sslProfile to use TLS v1.1 and TLS v1.2 only, you would set the value to TLSv1.1 TLSv1.2. If you do not specify a value, the sslProfile uses the TLS protocol specified by the system-wide configuration.",
                    "create": true
                },                            
                "caCertFile": {
                    "type": "path",
                    "description": "The absolute path to the database that contains the public certificates of trusted certificate authorities (CA).",
                    "deprecationName": "certDb",
                    "create": true
                },
                "certFile": {
                    "type": "path",
                    "description": "The absolute path to the file containing the PEM-formatted public certificate to be used on the local end of any connections using this profile.",
                    "create": true

                },
                "privateKeyFile": {
                    "type": "path",
                    "description": "The absolute path to the file containing the PEM-formatted private key for the above certificate.",
                    "deprecationName": "keyFile",
                    "create": true

                },
                "passwordFile": {
                    "type": "path",
                    "description": "If the above private key is password protected, this is the absolute path to a file containing the password that unlocks the certificate key. This file should be permission protected to limit access",
                    "create": true

                },
                "password": {
                    "type": "string",
                    "description": "(DEPRECATED) An alternative to storing the password in a file referenced by passwordFile is to supply the password right here in the configuration file.  This takes precedence over the passwordFile if both are specified. This attribute has been deprecated because it is unsafe to store plain text passwords in config files. Use the passwordFile instead",
                    "deprecated": true,
                    "create": true

                },
                "uidFormat": {
                    "type": "string",
                    "description": "A list of x509 client certificate fields that will be used to build a string that will uniquely identify the client certificate owner. For e.g. a value of 'cou' indicates that the uid will consist of c - common name concatenated with o - organization-company name concatenated with u - organization unit; or a value of 'o2' indicates that the uid will consist of o (organization name) concatenated with 2 (the sha256 fingerprint of the entire certificate) . Allowed values can be any combination of 'c'( ISO3166 two character country code), 's'(state or province), 'l'(Locality; generally - city), 'o'(Organization - Company Name), 'u'(Organization Unit - typically certificate type or brand), 'n'(CommonName - typically a user name for client certificates) and '1'(sha1 certificate fingerprint, as displayed in the fingerprints section when looking at a certificate with say a web browser is the hash of the entire certificate) and 2 (sha256 certificate fingerprint) and 5 (sha512 certificate fingerprint). The user identifier (uid) that is generated based on the uidFormat is a string which has a semi-colon as a separator between the components",
                    "create": true
                },
                "uidNameMappingFile": {
                    "type": "string",
                    "description": "The absolute path to the file containing the unique id to display name mapping",
                    "deprecationName": "displayNameFile",
                    "create": true
                }
            }
        },

        "authServicePlugin": {
            "description":"EXPERIMENTAL. Attributes for setting SASL plugin.",
            "referential": true,
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "authService": {
                    "type": "string",
                    "description": "(DEPRECATED) Address of a service to delegate authentication to. This attribute has been deprecated. Use the host and port attributes instead.",
                    "deprecated": true,
                    "create": true
                },
                "host": {
                    "description":"A host name, IPV4 or IPV6 literal, of the service to delegate to.",
                    "type": "string",
                    "default": "",
                    "create": true
                },
                "port": {
                    "description": "Port number of the service delegated host.",
                    "type": "string",
                    "default": "amqp",
                    "create": true

                },                
                "realm": {
                    "type": "string",
                    "description": "Value to set for hostname field on sasl-init",
                    "required": false,
                    "deprecationName": "saslInitHostname",
                    "create": true
                },
                "sslProfile": {
                    "type": "string",
                    "required": false,
                    "description": "Name of the sslProfile to use for the authentication service.",
                    "deprecationName": "authSslProfile",
                    "create": true
                }
            }
        },

        "listener": {
            "description": "Listens for incoming connections to the router.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "host": {
                    "description":"A host name, IPV4 or IPV6 literal, or the empty string. The empty string listens on all local addresses. A host name listens on all addresses associated with the name. An IPV6 literal address (or wildcard '[::]') listens only for IPV6. An IPV4 literal address (or wildcard '0.0.0.0') listens only for IPV4.",
                    "type": "string",
                    "default": "",
                    "create": true
                },
                "port": {
                    "description": "Port number or symbolic service name.  If '0', the router shall assign an ephemeral port to the listener and log the port number with a log of the form 'SERVER (notice) Listening on <host>:<assigned-port> (<listener-name>)'",
                    "type": "string",
                    "default": "amqp",
                    "create": true

                },
                "socketAddressFamily": {
                    "type": ["IPv4", "IPv6"],
                    "required": false,
                    "deprecationName": "protocolFamily",
                    "description": "['IPv4', 'IPv6'] IPv4: Internet Protocol version 4; IPv6: Internet Protocol version 6.  If not specified, the protocol family will be automatically determined from the address.",
                    "create": true
                },
                "role": {
                    "type": [
                        "normal",
                        "inter-router",
                        "route-container",
                        "edge-uplink"
                    ],
                    "default": "normal",
                    "description": "The role of an established connection. In the normal role, the connection is assumed to be used for AMQP clients that are doing normal message delivery over the connection.  In the inter-router role, the connection is assumed to be to another router in the network.  Inter-router discovery and routing protocols can only be used over inter-router connections. route-container role can be used for router-container connections, for example, a router-broker connection.  In the edge-uplink role, the connection is assumed to be between an edge router and an interior router.",
                    "create": true
                },
                "cost": {
                    "type": "integer",
                    "default": 1,
                    "required": false,
                    "create": true,
                    "description": "For the 'inter-router' role only.  This value assigns a cost metric to the inter-router connection.  The default (and minimum) value is one.  Higher values represent higher costs.  The cost is used to influence the routing algorithm as it attempts to use the path with the lowest total cost from ingress to egress."
                },
                "sslProfile": {
                    "type": "string",
                    "required": false,
                    "description": "Name of the sslProfile.",
                    "create": true
                },
                "saslMechanisms": {
                    "type": "string",
                    "required": false,
                    "description": "Space separated list of accepted SASL authentication mechanisms.",
                    "create": true
                },
                "authenticatePeer": {
                    "type": "boolean",
                    "default": false,
                    "description": "yes: Require the peer's identity to be authenticated; no: Do not require any authentication.",
                    "create": true
                },
                "saslPlugin": {
                    "type": "string",
                    "required": false,
                    "description": "EXPERIMENTAL. Name of the a sasl plugin configuration section to use for this listener (e.g. authServicePlugin).",
                    "create": true
                },
                "requireEncryption": {
                    "type": "boolean",
                    "default": false,
                    "description": "yes: Require the connection to the peer to be encrypted; no: Permit non-encrypted communication with the peer",
                    "create": true
                },
                "requireSsl": {
                    "type": "boolean",
                    "default": false,
                    "description": "yes: Require the use of SSL or TLS on the connection; no: Allow clients to connect without SSL or TLS.",
                    "create": true
                },
                "trustedCertsFile": {
                    "type": "path",
                    "description": "This optional setting can be used to reduce the set of available CAs for client authentication.  If used, this setting must provide the absolute path to a PEM file that contains the trusted certificates.",
                    "deprecationName": "trustedCerts",
                    "create": true
                },
                "maxFrameSize": {
                    "type": "integer",
                    "default": 16384,
                    "description": "The maximum frame size in octets that will be used in the connection-open negotiation with a connected peer.  The frame size is the largest contiguous set of uninterrupted data that can be sent for a message delivery over the connection. Interleaving of messages on different links is done at frame granularity. Policy settings, if specified, will overwrite this value. Defaults to 16384.",
                    "create": true
                },
                "maxSessions": {
                    "type": "integer",
                    "default": 32768,
                    "description": "The maximum number of sessions that can be simultaneously active on the connection. Setting this value to zero selects the default number of sessions. Policy settings, if specified, will overwrite this value. Defaults to 32768.",
                    "create": true
                },
                "maxSessionFrames": {
                    "type": "integer",
                    "description": "Session incoming window measured in transfer frames for sessions created on this connection. This is the number of transfer frames that may simultaneously be in flight for all links in the session. Setting this value to zero selects the default session window size. Policy settings, if specified, will overwrite this value. The numerical product of maxFrameSize and maxSessionFrames may not exceed 2^31-1. If (maxFrameSize x maxSessionFrames) exceeds 2^31-1 then maxSessionFrames is reduced to (2^31-1 / maxFrameSize). maxSessionFrames has a minimum value of 1. Defaults to 0 (unlimited window).",
                    "required": false,
                    "create": true
                },
                "idleTimeoutSeconds": {
                    "type": "integer",
                    "default": 16,
                    "description": "The idle timeout, in seconds, for connections through this listener.  If no frames are received on the connection for this time interval, the connection shall be closed.",
                    "required": false,
                    "create": true
                },
                "initialHandshakeTimeoutSeconds": {
                    "type": "integer",
                    "default": 0,
                    "description": "The timeout, in seconds, for the initial handshake for connections coming in through listeners.  If the time interval expires before the peer sends the AMQP OPEN frame, the connection shall be closed.  A value of zero (the default) disables this timeout.",
                    "required": false,
                    "create": true
                },
                "stripAnnotations": {
                    "type": ["in", "out", "both", "no"],
                    "default": "both",
                    "description": "['in', 'out', 'both', 'no'] in: Strip the dispatch router specific annotations only on ingress; out: Strip the dispatch router specific annotations only on egress; both: Strip the dispatch router specific annotations on both ingress and egress; no - do not strip dispatch router specific annotations",
                    "create": true
                },
                "linkCapacity": {
                    "type": "integer",
                    "create": true,
                    "required": false,
                    "description": "The capacity of links within this connection, in terms of message deliveries.  The capacity is the number of messages that can be in-flight concurrently for each link."
                },
                "multiTenant": {
                    "type": "boolean",
                    "create": true,
                    "required": false,
                    "default": false,
                    "description": "If true, apply multi-tenancy to endpoints connected at this listener.  The address space is defined by the virtual host (hostname field in the Open)."
                },
                "failoverUrls": {
                    "type": "string",
                    "create": true,
                    "required": false,
                    "deprecationName": "failoverList",
                    "description": "A comma-separated list of failover urls to be supplied to connected clients.  Form: [(amqp|amqps|ws|wss)://]host_or_ip[:port]"
                },
                "http": {
                    "type": "boolean",
                    "default": false,
                    "description": "Accept HTTP connections that can upgrade to AMQP over WebSocket. Plain AMQP connections are not accepted on this listener.",
                    "create": true
                },
                "httpRootDir": {
                    "type": "path",
                    "description": "Serve HTTP files from this directory, defaults to the installed stand-alone console directory",
                    "deprecationName": "httpRoot",
                    "create": true
                },
                "messageLoggingComponents": {
                    "type": "string",
                    "default": "none",
                    "description": "A comma separated list that indicates which components of the message should be logged. Defaults to 'none' (log nothing). If you want all properties and application properties of the message logged use 'all'. Specific components of the message can be logged by indicating the components via a comma separated list. The components are message-id, user-id, to, subject, reply-to, correlation-id, content-type, content-encoding, absolute-expiry-time, creation-time, group-id, group-sequence, reply-to-group-id, app-properties. The application-data part of the bare message will not be logged. No spaces are allowed",
                    "deprecationName": "logMessage",
                    "create": true
                }
            }
        },

        "connector": {
            "description": "Establishes an outgoing connection from the router.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "host": {
                    "description":"IP address: ipv4 or ipv6 literal or a host name",
                    "type": "string",
                    "default": "127.0.0.1",
                    "create": true
                },
                "port": {
                    "description": "Port number or symbolic service name.",
                    "type": "string",
                    "default": "amqp",
                    "create": true

                },
                "protocolFamily": {
                    "type": ["IPv4", "IPv6"],
                    "required": false,
                    "description": "['IPv4', 'IPv6'] IPv4: Internet Protocol version 4; IPv6: Internet Protocol version 6.  If not specified, the protocol family will be automatically determined from the address.",
                    "create": true
                },

                "role": {
                    "type": [
                        "normal",
                        "inter-router",
                        "route-container",
                        "edge-uplink"
                    ],
                    "default": "normal",
                    "description": "The role of an established connection. In the normal role, the connection is assumed to be used for AMQP clients that are doing normal message delivery over the connection.  In the inter-router role, the connection is assumed to be to another router in the network.  Inter-router discovery and routing protocols can only be used over inter-router connections. route-container role can be used for router-container connections, for example, a router-broker connection.  In the edge-uplink role, the connection is assumed to be between and edge router and an interior router.",
                    "create": true
                },
                "cost": {
                    "type": "integer",
                    "default": 1,
                    "required": false,
                    "create": true,
                    "description": "For the 'inter-router' role only.  This value assigns a cost metric to the inter-router connection.  The default (and minimum) value is one.  Higher values represent higher costs.  The cost is used to influence the routing algorithm as it attempts to use the path with the lowest total cost from ingress to egress."
                },
                "sslProfile": {
                    "type": "string",
                    "required": false,
                    "description": "Name of the sslProfile.",
                    "create": true
                },
                "saslMechanisms": {
                    "type": "string",
                    "required": false,
                    "description": "Space separated list of accepted SASL authentication mechanisms.",
                    "create": true
                },
                "allowRedirect": {
                    "type": "boolean",
                    "default": true,
                    "description": "Allow the peer to redirect this connection to another address.",
                    "create": true
                },
                "maxFrameSize": {
                    "type": "integer",
                    "default": 16384,
                    "description": "The maximum frame size in octets that will be used in the connection-open negotiation with a connected peer.  The frame size is the largest contiguous set of uninterrupted data that can be sent for a message delivery over the connection. Interleaving of messages on different links is done at frame granularity. Policy settings will not overwrite this value. Defaults to 16384.",
                    "create": true
                },
                "maxSessions": {
                    "type": "integer",
                    "default": 32768,
                    "description": "The maximum number of sessions that can be simultaneously active on the connection. Setting this value to zero selects the default number of sessions. Policy settings will not overwrite this value. Defaults to 32768.",
                    "create": true
                },
                "maxSessionFrames": {
                    "type": "integer",
                    "description": "Session incoming window measured in transfer frames for sessions created on this connection. This is the number of transfer frames that may simultaneously be in flight for all links in the session. Setting this value to zero selects the default session window size. Policy settings will not overwrite this value. The numerical product of maxFrameSize and maxSessionFrames may not exceed 2^31-1. If (maxFrameSize x maxSessionFrames) exceeds 2^31-1 then maxSessionFrames is reduced to (2^31-1 / maxFrameSize). maxSessionFrames has a minimum value of 1.  Defaults to 0 (unlimited window).",
                    "required": false,
                    "create": true
                },
                "idleTimeoutSeconds": {
                    "type": "integer",
                    "default": 16,
                    "description": "The idle timeout, in seconds, for connections through this connector.  If no frames are received on the connection for this time interval, the connection shall be closed.",
                    "create": true
                },
                "stripAnnotations": {
                    "type": ["in", "out", "both", "no"],
                    "default": "both",
                    "description": "['in', 'out', 'both', 'no'] in: Strip the dispatch router specific annotations only on ingress; out: Strip the dispatch router specific annotations only on egress; both: Strip the dispatch router specific annotations on both ingress and egress; no - do not strip dispatch router specific annotations",
                    "create": true
                },
                "linkCapacity": {
                    "type": "integer",
                    "create": true,
                    "required": false,
                    "description": "The capacity of links within this connection, in terms of message deliveries.  The capacity is the number of messages that can be in-flight concurrently for each link."
                },
                "verifyHostname": {
                    "type": "boolean",
                    "default": true,
                    "description": "yes: Ensures that when initiating a connection (as a client) the host name in the URL to which this connector connects to matches the host name in the digital certificate that the peer sends back as part of the SSL connection; no: Does not perform host name verification",
                    "deprecationName": "verifyHostName",
                    "create": true
                },
                "saslUsername": {
                    "type": "string",
                    "required": false,
                    "description": "The user name that the connector is using to connect to a peer.",
                    "create": true
                },
                "saslPassword": {
                    "type": "string",
                    "required": false,
                    "description": "The password that the connector is using to connect to a peer.",
                    "create": true,
                    "hidden": true
                },
                "messageLoggingComponents": {
                    "type": "string",
                    "default": "none",
                    "description": "A comma separated list that indicates which components of the message should be logged (no spaces allowed between list components). Defaults to 'none' (log nothing). If you want all properties and application properties of the message logged use 'all'. Specific components of the message can be logged by indicating the components via a comma separated list. The components are message-id, user-id, to, subject, reply-to, correlation-id, content-type, content-encoding, absolute-expiry-time, creation-time, group-id, group-sequence, reply-to-group-id, app-properties. The application-data part of the bare message will not be logged. This log message is written to the MESSAGE logging module. In the 'log' entity, set 'module' property to MESSAGE or DEFAULT and 'enable' to trace+ to see this log message",
                    "deprecationName": "logMessage",
                    "create": true
                },
                "failoverUrls": {
                    "type": "string",
                    "description": "A read-only, comma-separated list of failover urls. ",
                    "deprecationName": "failoverList",
                    "create": false
                    
                }            
            }
        },

        "log": {
            "description": "Configure logging for a particular module. You can use the `UPDATE` operation to change log settings while the router is running.",
            "extends": "configurationEntity",
            "operations": ["UPDATE"],
            "attributes": {
                "module": {
                    "type":[
                        "ROUTER",
                        "ROUTER_CORE",
                        "ROUTER_HELLO",
                        "ROUTER_LS",
                        "ROUTER_MA",
                        "MESSAGE",
                        "SERVER",
                        "AGENT",
                        "CONTAINER",
                        "ERROR",
                        "POLICY",
                        "HTTP",
                        "CONN_MGR",
                        "PYTHON",
                        "DEFAULT"
                    ],
                    "required": true,
                    "description": "Module to configure. The special module 'DEFAULT' specifies defaults for all modules.",
                    "update": true
                },
                "enable": {
                    "type": "string",
                    "description": "Levels are: trace, debug, info, notice, warning, error, critical. The enable string is a comma-separated list of levels. A level may have a trailing '\\+' to enable that level and above. For example 'trace,debug,warning+' means enable trace, debug, warning, error and critical. The value 'none' means disable logging for the module.",
                    "update": true
                },
                "includeTimestamp": {
                    "type": "boolean",
                    "description": "Include timestamp in log messages.",
                    "deprecationName": "timestamp",
                    "update": true
                },
                "includeSource": {
                    "type": "boolean",
                    "description": "Include source file and line number in log messages.",
                    "deprecationName": "source",
                    "update": true
                },
                "outputFile": {
                    "type": "string",
                    "description": "Where to send log messages. Can be 'stderr', 'stdout', 'syslog' or a file name.",
                    "deprecationName": "output",
                    "update": true
                }
            }
        },

        "logStats": {
            "description": "histogram of the different severity-levels of events on the given log.",
            "extends": "operationalEntity",
            "attributes": {
                "traceCount": {
                    "description": "How many trace-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "debugCount": {
                    "description": "How many debug-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "infoCount": {
                    "description": "How many info-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "noticeCount": {
                    "description": "How many notice-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "warningCount": {
                    "description": "How many warning-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "errorCount": {
                    "description": "How many error-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                } ,
                "criticalCount": {
                    "description": "How many critical-level events have happened on this log.",
                    "graph": true,
                    "type": "integer"
                }
            }
        },

        "router.config.address": {
            "description": "Entity type for address configuration.  This is used to configure the treatment of message-routed deliveries within a particular address-space.  The configuration controls distribution and address phasing.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "prefix": {
                    "type": "string",
                    "description": "The address prefix for the configured settings. Cannot be used with a pattern attribute.",
                    "create": true,
                    "required": false
                },
                "pattern": {
                    "type": "string",
                    "description": "A wildcarded pattern for address matching. Incoming addresses are matched against this pattern. Matching addresses use the configured settings. The pattern consists of one or more tokens separated by a forward slash '/'. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #.  The * token matches any single token.  The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence. Cannot be used with a prefix attribute.",
                    "create": true,
                    "required": false
                },
                "distribution": {
                    "type": ["multicast", "closest", "balanced", "unavailable"],
                    "description": "Treatment of traffic associated with the address",
                    "create": true,
                    "required": false,
                    "default": "balanced"
                },
                "waypoint": {
                    "type": "boolean",
                    "description": "Designates this address space as being used for waypoints.  This will cause the proper address-phasing to be used.",
                    "create": true,
                    "required": false,
                    "default": false
                },
                "ingressPhase": {
                    "type": "integer",
                    "description": "Advanced - Override the ingress phase for this address",
                    "create": true,
                    "required": false
                },
                "egressPhase": {
                    "type": "integer",
                    "description": "Advanced - Override the egress phase for this address",
                    "create": true,
                    "required": false
                }
            }
        },

        "router.config.linkRoute": {
            "description": "Entity type for link-route configuration.  This is used to identify remote containers that shall be destinations for routed link-attaches.  The link-routing configuration applies to an addressing space defined by a prefix or a pattern.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "prefix": {
                    "type": "string",
                    "description": "The address prefix for the configured settings. Cannot be used with the pattern attribute.",
                    "create": true,
                    "required": false
                },
                "pattern": {
                    "type": "string",
                    "description": "A wildcarded pattern for address matching. Link addresses are matched against this pattern. Matching addresses use the configured settings. The pattern consists of one or more tokens separated by a forward slash '/'. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #.  The * token matches any single token.  The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence. Cannot be used with the prefix attribute.",
                    "create": true,
                    "required": false
                },
                "containerId": {
                    "type": "string",
                    "description": "ContainerID for the target container. Only one of containerId or connection should be specified for a linkRoute. Specifying both will result in the linkRoute not being created.",
                    "create": true,
                    "required": false
                },
                "connection": {
                    "type": "string",
                    "description": "The name from a connector or listener. Only one of containerId or connection should be specified for a linkRoute. Specifying both will result in the linkRoute not being created.",
                    "create": true,
                    "required": false
                },
                "distribution": {
                    "type": ["linkBalanced"],
                    "description": "Treatment of traffic associated with the address",
                    "create": true,
                    "required": false,
                    "default": "linkBalanced"
                },
                "direction": {
                    "type": ["in", "out"],
                    "description": "The permitted direction of links: 'in' means client senders; 'out' means client receivers",
                    "create": true,
                    "deprecationName": "dir",
                    "required": true
                },
                "operStatus": {
                    "type": ["inactive", "active"],
                    "description": "The operational status of this linkRoute: inactive - The remote container is not connected; active - the remote container is connected and ready to accept link routed attachments.",
                    "create": false
                }
            }
        },

        "router.config.autoLink": {
            "description": "Entity type for configuring auto-links.  Auto-links are links whose lifecycle is managed by the router.  These are typically used to attach to waypoints on remote containers (brokers, etc.).",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "addr": {
                    "type": "string",
                    "description": "The address of the provisioned object",
                    "create": true,
                    "required": true
                },
                "direction": {
                    "type": ["in", "out"],
                    "description": "The direction of the link to be created.  In means into the router, out means out of the router.",
                    "create": true,
                    "deprecationName": "dir",
                    "required": true
                },
                "phase": {
                    "type": "integer",
                    "description": "The address phase for this link.  Defaults to '0' for 'out' links and '1' for 'in' links.",
                    "create": true,
                    "required": false
                },
                "containerId": {
                    "type": "string",
                    "description": "ContainerID for the target container. Only one of containerId or connection should be specified for an autoLink. Specifying both will result in the autoLink not being created",
                    "create": true,
                    "required": false
                },
                "connection": {
                    "type": "string",
                    "description": "The name from a connector or listener. Only one of containerId or connection should be specified for an autoLink. Specifying both will result in the autoLink not being created",
                    "create": true,
                    "required": false
                },
                "externalAddr": {
                    "type": "string",
                    "description": "If present, an alternate address of the node on the remote container.  This is used if the node has a different address than the address used internally by the router to route deliveries.",
                    "create": true,
                    "required": false
                },
                "linkRef": {
                    "type": "string",
                    "description": "Reference to the org.apache.qpid.dispatch.router.link if the link exists",
                    "create": false
                },
                "operStatus": {
                    "type": ["inactive", "attaching", "failed", "active", "quiescing", "idle"],
                    "description": "The operational status of this autoLink: inactive - The remote container is not connected; attaching - the link is attaching to the remote node; failed - the link attach failed; active - the link is attached and operational; quiescing - the link is transitioning to idle state; idle - the link is attached but there are no deliveries flowing and no unsettled deliveries.",
                    "create": false
                },
                "lastError": {
                    "type": "string",
                    "description": "The error description from the last attach failure",
                    "create": false
                }
            }
        },

        "router.config.exchange": {
            "description":"[EXPERIMENTAL] Defines a topic exchange.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "address": {
                    "description": "The address of the exchange. Used by the message publisher as the target for sending messages.",
                    "type": "string",
                    "create": true,
                    "required": true
                },
                "phase": {
                    "type": "integer",
                    "description": "The address phase for the exchange.  Defaults to '0'.",
                    "create": true,
                    "required": false
                },
                "alternateAddress": {
                    "description": "The address to forward the message to if no bindings are matched.",
                    "type": "string",
                    "create": true,
                    "required": false
                },
                "alternatePhase": {
                    "type": "integer",
                    "description": "The address phase for the alternateAddress.  Defaults to '0'.",
                    "create": true,
                    "required": false
                },
                "matchMethod": {
                    "description": "Key matching algorithm used. 'amqp' uses the legacy AMQP topic exchange wildcard match method as described in the pre-1.0 drafts. 'mqtt' uses the MQTT topic filter wildcard match method.",
                    "type": ["amqp", "mqtt"],
                    "default": "amqp",
                    "required": false,
                    "create": true
                },
                "bindingCount": {
                    "description": "The number of bindings associated with this exchange.",
                    "type": "integer",
                    "create": false
                },
                "receivedCount": {
                    "description": "The total number of deliveries received by this exchange.",
                    "type": "integer",
                    "create": false
                },
                "droppedCount": {
                    "description": "The total number of deliveries dropped due to the lack of an outgoing subscription.",
                    "type": "integer",
                    "create": false
                },
                "forwardedCount": {
                    "description": "The total number of deliveries forwarded via matched bindings or to the alternateAddress",
                    "type": "integer",
                    "create": false
                },
                "divertedCount": {
                    "description": "A count of those deliveries that were forwarded via the alternateAddress only.  This is a subset of the forwardedCount.",
                    "type": "integer",
                    "create": false
                }
            }
        },

        "router.config.binding": {
            "description":"[EXPERIMENTAL] Defines a keyed next hop binding for a topic exchange. The subject field of the messages arriving at the exchange is compared against the binding's key value using the exchange's matchMethod.  If the subject matches the key the message is forwarded to the nextHopAddress. The nextHopAddress overrides the message's original destination.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "DELETE"],
            "attributes": {
                "exchangeName": {
                    "description": "The name of the exchange to bind.",
                    "type": "string",
                    "create": true,
                    "required": true
                },
                "bindingKey": {
                    "description": "Pattern to compare against incoming message's subject.  The key is a string of zero or more tokens and wildcards. The format depends on the matchMethod configured for the exchange. For AMQP each token is delimited by the '.' character and wild-card tokens '*' matches a single token and '#' matches zero or more tokens. For MQTT each token is delimited by the '/' character and wildcard tokens '+' matches a single token and '#' matches zero or more tokens at the end of the topic. If a key is not provided the binding will match all messages arriving at the exchange (fanout behavior).",
                    "type": "string",
                    "create": true,
                    "required": false
                },
                "nextHopAddress": {
                    "description": "The address to forward the message to when the message's topic string matches the binding key pattern.  This address is used by message consumers as the source of incoming messages.",
                    "type": "string",
                    "create": true,
                    "required": true
                },
                "nextHopPhase": {
                    "type": "integer",
                    "description": "The address phase used when forwarding messages that match this binding.",
                    "create": true,
                    "required": false
                },
                "matchedCount": {
                    "description": "Total number of deliveries that matched this binding.",
                    "type": "integer"
                }
            }
        },

        "router.link": {
            "description": "Link to another AMQP endpoint: router node, client or other AMQP process.",
            "extends": "operationalEntity",
            "operations": ["UPDATE"],
            "attributes": {
                "adminStatus": {
                    "type": ["enabled", "disabled"],
                    "default": "enabled",
                    "update": true
                },
                "operStatus": {
                    "type": ["up", "down", "quiescing", "idle"]
                },
                "linkName": {
                    "type": "string",
                    "description": "Name assigned to the link in the Attach."
                },
                "linkType": {
                    "type": ["endpoint", "router-control", "inter-router"],
                    "description": "Type of link: endpoint: a link to a normally connected endpoint; inter-router: a link to another router in the network."
                },
                "linkDir": {
                    "type": ["in", "out"],
                    "description": "Direction of delivery flow over the link, inbound or outbound to or from the router."
                },
                "owningAddr": {
                    "type": "string",
                    "description": "Address assigned to this link during attach: The target for inbound links or the source for outbound links."
                },
                "capacity": {
                    "type": "integer",
                    "description": "The capacity, in deliveries, for the link.  The number of undelivered plus unsettled deliveries shall not exceed the capacity.  This is enforced by link flow control."
                },
                "peer": {
                    "type": "string",
                    "description": "Identifier of the paired link if this is an attach-routed link."
                },
                "undeliveredCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The number of undelivered messages pending for the link."
                },
                "unsettledCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The number of unsettled deliveries awaiting settlement on the link"
                },
                "deliveryCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of deliveries that have traversed this link."
                },
                "presettledCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of pre-settled deliveries."
                },
                "droppedPresettledCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of pre-settled deliveries that were dropped."
                },
                "acceptedCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of accepted deliveries."
                },
                "rejectedCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of rejected deliveries."
                },
                "releasedCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of released deliveries."
                },
                "modifiedCount": {
                    "type": "integer",
                    "graph": true,
                    "description": "The total number of modified deliveries."
                },
                "ingressHistogram": {
                    "type": "list",
                    "description": "For outgoing links on connections with 'normal' role.  This histogram shows the number of settled deliveries on the link that ingressed the network at each interior router node."
                }
            }
        },

        "router.address": {
            "description": "AMQP address managed by the router.",
            "extends": "operationalEntity",
            "attributes": {
                "distribution": {
                    "type": ["flood", "multicast", "closest", "balanced", "linkBalanced", "unavailable"],
                    "description": "Forwarding treatment for the address: flood - messages delivered to all subscribers along all available paths (this will cause duplicate deliveries if there are redundant paths); multicast - one copy of each message delivered to all subscribers; closest - messages delivered to only the closest subscriber; balanced - messages delivered to one subscriber with load balanced across subscribers; linkBalanced - for link-routing, link attaches balanced across destinations; unavailable - this address is unavailable, link attaches to an address of unavailable distribution will be rejected."
                },
                "inProcess": {
                    "type": "integer",
                    "description": "The number of in-process subscribers for this address"
                },
                "subscriberCount": {
                    "type": "integer",
                    "description": "The number of local subscribers for this address (i.e. attached to this router)",
                    "graph": true
                },
                "remoteCount": {
                    "type": "integer",
                    "description": "The number of remote routers that have at least one subscriber to this address",
                    "graph": true
                },
                "containerCount": {
                    "type": "integer",
                    "description": "The number of attached containers that serve this route address",
                    "graph": true
                },
                "deliveriesIngress": {
                    "type": "integer",
                    "description": "The number of deliveries to this address that entered the router network on this router",
                    "graph": true
                },
                "deliveriesEgress": {
                    "type": "integer",
                    "description": "The number of deliveries to this address that exited the router network on this router",
                    "graph": true
                },
                "deliveriesTransit": {
                    "type": "integer",
                    "description": "The number of deliveries to this address that transited this router to another router",
                    "graph": true
                },
                "deliveriesToContainer": {
                    "type": "integer",
                    "description": "The number of deliveries to this address that were given to an in-process subscriber",
                    "graph": true
                },
                "deliveriesFromContainer": {
                    "type": "integer",
                    "description": "The number of deliveries to this address that were originated from an in-process entity",
                    "graph": true
                },
                "deliveriesIngressRouteContainer": {
                    "type": "integer",
                    "description": "Number of deliveries that were received from a route-container address.",
                    "graph": true
                },
                "deliveriesEgressRouteContainer": {
                    "type": "integer",
                    "description": "Number of deliveries that were sent to a route-container address.",
                    "graph": true
                },
                "key": {
                    "description": "Internal unique (to this router) key to identify the address",
                    "type": "string"
                },
                "remoteHostRouters": {
                    "type": "list",
                    "description": "List of remote routers on which there is a destination for this address."
                },
                "transitOutstanding": {
                    "type": "list",
                    "description": "List of numbers of outstanding deliveries across a transit (inter-router) link for this address.  This is for balanced distribution only."
                },
                "trackedDeliveries": {
                    "type": "integer",
                    "description": "Number of transit deliveries being tracked for this address (for balanced distribution)."
                },
                "viaUplink": {
                    "type": "boolean",
                    "description": "True if there are consumers for this address via the edge uplink (relevant on edge routers only)."
                }
            }
        },

        "router.node": {
            "description": "Remote router node connected to this router.",
            "extends": "operationalEntity",
            "attributes": {
                "id": {
                    "description": "Remote node identifier.",
                    "type": "string"
                },
                "protocolVersion": {
                    "description": "Router-protocol version supported by the node.",
                    "type": "integer"
                },
                "mode": {
                    "description": "Mode of this router: interior or edge.",
                    "type": "string"
                },
                "instance": {
                    "description": "Remote node boot number.",
                    "type": "integer"
                },
                "linkState": {
                    "description": "List of remote node's neighbours.",
                    "type": "list"
                },
                "nextHop": {
                    "description": "Neighbour ID of next hop to remote node from here.",
                    "type": "string"
                },
                "validOrigins": {
                    "description": "List of valid origin nodes for messages arriving via the re mote node, used for duplicate elimination in redundant networks.",
                    "type": "list"
                },
                "address": {
                    "description": "Address of the remote node",
                    "type": "string"
                },
                "routerLink": {
                    "description": "Local link to remote node",
                    "type": "entityId"
                },
                "cost": {
                    "description": "Reachability cost",
                    "type": "integer"
                },
                "lastTopoChange": {
                     "description": "Timestamp showing the most recent change to this node's neighborhood.",
                     "type": "integer"
                },
                "index": {
                    "description": "Index number used in statistics histograms for this router node.  This index is specific to this router.",
                    "type": "integer"
                }

            }
        },

        "connection": {
            "description": "Connections to the router's container.",
            "extends": "operationalEntity",
            "attributes": {
                "container": {
                    "description": "The container for this connection",
                    "type": "string"
                } ,
                "opened": {
                    "type": "boolean",
                    "description": "The connection has been opened (i.e. AMQP OPEN)"
                },
                "host": {
                    "description": "IP address and port number in the form addr:port.",
                    "type": "string"
                },
                "dir": {
                    "description": "Direction of connection establishment in or out of the router.",
                    "type": ["in", "out"]
                },
                "role": {"type": "string"},
                "isAuthenticated": {
                    "description": "Indicates whether the identity of the connection's user is authentic.",
                    "type": "boolean"
                },
                "isEncrypted": {
                    "description": "Indicates whether the connection content is encrypted.",
                    "type": "boolean"
                },
                "sasl": {
                    "description": "SASL mechanism in effect for authentication.",
                    "type": "string"
                },
                "user": {
                    "description": "Identity of the authenticated user.",
                    "type": "string"
                },
                "ssl": {
                    "description": "True iff SSL/TLS is in effect for this connection.",
                    "type": "boolean"
                },
                "sslProto": {
                    "description": "SSL protocol name",
                    "type": "string"
                },
                "sslCipher": {
                    "description": "SSL cipher name",
                    "type": "string"
                },
                "sslSsf": {
                    "description": "SSL strength factor in effect",
                    "type": "integer"
                },
                "tenant": {
                    "description": "If multi-tenancy is on for this connection, the tenant space in effect",
                    "type": "string"
                },
                "properties": {
                    "description": "Connection properties supplied by the peer.",
                    "type": "map"
                }
            }
        },

        "allocator": {
            "description": "Memory allocation pool.",
            "extends": "operationalEntity",
            "attributes": {
                "typeName": {"type": "string"},
                "typeSize": {"type": "integer"},
                "transferBatchSize": {"type": "integer"},
                "localFreeListMax": {"type": "integer", "graph": true},
                "globalFreeListMax": {"type": "integer", "graph": true},
                "totalAllocFromHeap": {"type": "integer", "graph": true},
                "totalFreeToHeap": {"type": "integer", "graph": true},
                "heldByThreads": {"type": "integer", "graph": true},
                "batchesRebalancedToThreads": {"type": "integer", "graph": true},
                "batchesRebalancedToGlobal": {"type": "integer", "graph": true}
            }
        },

        "console": {
            "description": "(DEPRECATED) Start a websocket/tcp proxy and http file server to serve the web console",
            "extends": "configurationEntity",
            "singleton": true,
            "deprecated": true,
            "attributes": {
                "listener": {
                    "type": "string",
                    "description": "The name of the listener to send the proxied tcp traffic to."
                },
                "wsport": {
                    "type": "integer",
                    "description": "port on which to listen for websocket traffic",
                    "default": 5673
                },
                "proxy": {
                    "type": "string",
                    "required": true,
                    "description": "The full path to the proxy program to run."
                 },
                "home": {
                    "type": "string",
                    "required": true,
                    "description": "The full path to the html/css/js files for the console."
                },
                "args": {
                    "type": "string",
                    "description": "Optional args to pass the proxy program for logging, authentication, etc."
                }

            }
        },

        "policy": {
            "description": "Defines global connection limit",
            "extends": "configurationEntity",
            "singleton": true,
            "attributes": {
                "maxConnections": {
                    "type": "integer",
                    "default": 65535,
                    "description": "The maximum number of concurrent client connections allowed for this router. This limit is always enforced, even if no other policy settings have been defined. The limit is applied to all incoming connections regardless of remote host, authenticated user, or targeted vhost.",
                    "required": false,
                    "create": true
                },
                "enableVhostPolicy": {
                    "type": "boolean",
                    "default": false,
                    "description": "Enables the router to enforce the connection denials and resource limits defined in the configured vhost policies.",
                    "required": false,
                    "create": true
                },
                "enableVhostNamePatterns": {
                    "type": "boolean",
                    "default": false,
                    "description": "Enable vhost name patterns. When false vhost hostnames are treated as literal strings. When true vhost hostnames are treated as match patterns.",
                    "required": false,
                    "create": true
                },
                "policyDir": {
                    "type": "path",
                    "default": "",
                    "description": "The absolute path to a directory that holds vhost policy definition files in JSON format (*.json). The router processes all of the vhost policies in each JSON file that is in this directory.",
                    "required": false,
                    "create": true
                },
                "defaultVhost": {
                    "type": "string",
                    "default": "$default",
                    "description": "The name of the default vhost policy. This policy rule set is applied to a connection for which a vhost policy has not otherwise been configured. Processing for the default vhost is enabled by default and set to select vhost '$default'. To disable default vhost processing set defaultVhost to blank or do not define a vhost named '$default'.",
                    "required": false,
                    "create": true
                },
                "connectionsProcessed": {"type": "integer", "graph": true},
                "connectionsDenied": {"type": "integer", "graph": true},
                "connectionsCurrent": {"type": "integer", "graph": true}
            }
        },

        "vhost": {
            "description": "AMQP virtual host policy definition of users, user groups, allowed remote hosts, and AMQP restrictions.",
            "extends": "configurationEntity",
            "operations": ["CREATE", "UPDATE", "DELETE"],
            "attributes": {
                "hostname": {
                    "type": "string",
                    "description": "The hostname of the vhost. This vhost policy will be applied to any client connection that is directed to this hostname.",
                    "deprecationName": "id",
                    "required": true,
                    "create": true
                },
                "maxConnections": {
                    "type": "integer",
                    "default": 65535,
                    "description": "The global maximum number of concurrent client connections allowed for this vhost.",
                    "required": false,
                    "create": true,
                    "update": true
                },
                "maxConnectionsPerUser": {
                    "type": "integer",
                    "default": 65535,
                    "description": "The maximum number of concurrent client connections allowed for any user.",
                    "required": false,
                    "create": true,
                    "update": true
                },
                "maxConnectionsPerHost": {
                    "type": "integer",
                    "default": 65535,
                    "description": "The maximum number of concurrent client connections allowed for any remote host (the host from which the client is connecting).",
                    "required": false,
                    "create": true,
                    "update": true
                },
                "allowUnknownUser": {
                    "type": "boolean",
                    "description": "Whether unknown users (users who are not members of a defined user group) are allowed to connect to the vhost. Unknown users are assigned to the '$default' user group and receive '$default' settings.",
                    "default": false,
                    "required": false,
                    "create": true,
                    "update": true
                },
                "groups": {
                    "type": "map",
                    "description": "A map where each key is a vhost name and each value is a map of the settings for users of that vhost.",
                    "required": false,
                    "create": true,
                    "update": true
                }
            }
        },

        "vhostUserGroupSettings": {
            "description": "Policy settings for users connecting to a vhost. Configuration files including this section must use .json format.",
            "extends": "configurationEntity",
            "attributes": {
                "users": {
                    "type": "string",
                    "description": "A list of authenticated users for this user group. Use commas to separate multiple users. A user may belong to only one vhost user group.",
                    "required": true
                },
                "remoteHosts": {
                    "type": "string",
                    "description": "A list of remote hosts from which the users may connect. A host can be a hostname, IP address, or IP address range. Use commas to separate multiple hosts. To allow access from all remote hosts, specify a wildcard '*'. To deny access from all remote hosts, leave this attribute blank.",
                    "required": true
                },
                "maxFrameSize": {
                    "type": "integer",
                    "description": "The largest frame, in bytes, that may be sent on this connection. Non-zero policy values overwrite values specified for a listener object (AMQP Open, max-frame-size).",
                    "default": 16384,
                    "required": false,
                    "create": true
                },
                "maxSessionWindow": {
                    "type": "integer",
                    "description": "The incoming capacity for new AMQP sessions, measured in octets. Non-zero policy values overwrite values specified for a listener object (AMQP Begin, incoming-window).",
                    "default": 1638400,
                    "required": false,
                    "create": true
                },
                "maxSessions": {
                    "type": "integer",
                    "description": "The maximum number of sessions that may be created on this connection. Non-zero policy values overwrite values specified for a listener object (AMQP Open, channel-max).",
                    "default": 32768,
                    "required": false,
                    "create": true
                },
                "maxSenders": {
                    "type": "integer",
                    "description": "The maximum number of sending links that may be created on this connection. A value of '0' disables all sender links.",
                    "default": 2147483647,
                    "required": false,
                    "create": true
                },
                "maxReceivers": {
                    "type": "integer",
                    "description": "The maximum number of receiving links that may be created on this connection. A value of '0' disables all receiver links.",
                    "default": 2147483647,
                    "required": false,
                    "create": true
                },
                "allowDynamicSource": {
                    "type": "boolean",
                    "description": "Whether this connection is allowed to create dynamic receiving links (links to resources that do not exist on the peer). A value of 'true' means that users are able to automatically create resources on the peer system.",
                    "default": false,
                    "required": false,
                    "create": true
                },
                "allowAnonymousSender": {
                    "type": "boolean",
                    "description": "Whether this connection is allowed to create sending links if the sender does not provide a target address. By prohibiting anonymous senders, the router only needs to verify once, when the link is created, that the sender is permitted to send messages to the target address. The router does not need to verify each message that is sent on the link. A value of 'true' means that users may send messages to any address. Allowing anonymous senders can also decrease performance: if the sender does not specify a target address, then the router must parse each message to determine how to route it.",
                    "default": false,
                    "required": false,
                    "create": true
                },
                "allowUserIdProxy": {
                    "type": "boolean",
                    "description": "Whether this connection is allowed to send messages with a user ID that is different than the connection's authenticated user name.",
                    "default": false,
                    "required": false,
                    "create": true
                },
                "sources": {
                    "type": "string",
                    "description": "A list of source addresses from which users in this group may receive messages. To specify multiple addresses, separate the addresses with either a comma or a space. If you do not specify any addresses, users in this group are not allowed to receive messages from any addresses. You can use the substitution token '${user}' to specify an address that contains a user's authenticated user name. You can use an asterisk ('*') wildcard to match one or more characters in an address. However, this wildcard is only recognized if it is the last character in the address name. You may specify attributes 'sources' or 'sourcePattern' but not both at the same time.",
                    "required": false,
                    "create": true
                },
                "targets": {
                    "type": "string",
                    "description": "A list of target addresses to which users in this group may send messages. To specify multiple addresses, separate the addresses with either a comma or a space. If you do not specify any addresses, users in this group are not allowed to send messages to any addresses. You can use the substitution token '${user}' to specify an address that contains a user's authenticated user name. You can use an asterisk ('*') wildcard to match one or more characters in an address. However, this wildcard is only recognized if it is the last character in the address name. You may specify attributes 'targets' or 'targetPattern' but not both at the same time.",
                    "required": false,
                    "create": true
                },
                "sourcePattern": {
                    "type": "string",
                    "description": "A wildcarded pattern for matching source addresses from which users in this group may receive messages. The pattern consists of one or more tokens separated by a forward slash '/'. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #.  The * token matches any single token.  The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence. To specify multiple addresses, separate the addresses with either a comma or a space. You can use the text string '${user}' in a token to specify an address that contains a user's authenticated user name. If you do not specify any addresses, users in this group are not allowed to receive messages from any addresses. You may specify attributes 'sources' or 'sourcePattern' but not both at the same time.",
                    "create": true,
                    "required": false
                },
                "targetPattern": {
                    "type": "string",
                    "description": "A wildcarded pattern for matching target addresses to which users in this group may send messages. The pattern consists of one or more tokens separated by a forward slash '/'. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #.  The * token matches any single token.  The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence. To specify multiple addresses, separate the addresses with either a comma or a space. You can use the text string '${user}' in a token to specify an address that contains a user's authenticated user name. If you do not specify any addresses, users in this group are not allowed to send messages to any addresses. You may specify attributes 'targets' or 'targetPattern' but not both at the same time.",
                    "create": true,
                    "required": false
                }
            }
        },

        "vhostStats": {
            "description": "Virtual host connection and access statistics.",
            "extends": "operationalEntity",
            "attributes": {
                "id": {
                    "type": "string",
                    "description": "The vhost name. DEPRECATED - use 'hostname' instead."
                },
                "hostname": {
                    "type": "string",
                    "description": "The vhost name."
                },
                "connectionsApproved": {"type": "integer", "graph": true},
                "connectionsDenied": {"type": "integer", "graph": true},
                "connectionsCurrent": {"type": "integer", "graph": true},
                "perUserState": {
                    "type": "map",
                    "description": "A map where the key is the authenticated user name and the value is a list of the user's connections."
                },
                "perHostState": {
                    "type": "map",
                    "description": "A map where the key is the host name and the value is a list of the host's connections."
                },

                "sessionDenied": {"type": "integer", "graph": true},
                "senderDenied": {"type": "integer", "graph": true},
                "receiverDenied": {"type": "integer", "graph": true}
            }
        },
        
        "dummy": {
            "description": "Dummy entity for test purposes.",
            "extends": "entity",
            "operations": ["CREATE", "READ", "UPDATE", "DELETE", "CALLME"],
            "attributes": {
                "arg1": {"type": "string", "create": true, "update": true},
                "arg2": {"type": "string", "create": true, "update": true},
                "num1": {"type": "integer", "create": true, "update": true},
                "num2": {"type": "integer", "create": true, "update": true}
            }
        }
    }
}
